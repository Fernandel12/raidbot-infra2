package rbdb

import (
	context "context"
	fmt "fmt"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/v2/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	gorm "gorm.io/gorm"
	strings "strings"
	time "time"
)

type ActivityORM struct {
	CreatedAt      *time.Time
	Id             int64 `gorm:"primaryKey"`
	Kind           int32
	LicenseKey     *LicenseKeyORM `gorm:"foreignKey:LicenseKeyId;references:Id"`
	LicenseKeyId   *int64
	Payment        *PaymentORM `gorm:"foreignKey:PaymentId;references:Id"`
	PaymentId      *int64
	Subscription   *SubscriptionORM `gorm:"foreignKey:SubscriptionId;references:Id"`
	SubscriptionId *int64
	UpdatedAt      *time.Time
	User           *UserORM `gorm:"foreignKey:UserId;references:Id"`
	UserId         *int64
}

// TableName overrides the default tablename generated by GORM
func (ActivityORM) TableName() string {
	return "activities"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Activity) ToORM(ctx context.Context) (ActivityORM, error) {
	to := ActivityORM{}
	var err error
	if prehook, ok := interface{}(m).(ActivityWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.Kind = int32(m.Kind)
	if m.User != nil {
		tempUser, err := m.User.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.User = &tempUser
	}
	if m.LicenseKey != nil {
		tempLicenseKey, err := m.LicenseKey.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.LicenseKey = &tempLicenseKey
	}
	if m.Payment != nil {
		tempPayment, err := m.Payment.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Payment = &tempPayment
	}
	if m.Subscription != nil {
		tempSubscription, err := m.Subscription.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Subscription = &tempSubscription
	}
	if posthook, ok := interface{}(m).(ActivityWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *ActivityORM) ToPB(ctx context.Context) (Activity, error) {
	to := Activity{}
	var err error
	if prehook, ok := interface{}(m).(ActivityWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.Kind = Activity_Kind(m.Kind)
	if m.User != nil {
		tempUser, err := m.User.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.User = &tempUser
	}
	if m.LicenseKey != nil {
		tempLicenseKey, err := m.LicenseKey.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.LicenseKey = &tempLicenseKey
	}
	if m.Payment != nil {
		tempPayment, err := m.Payment.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Payment = &tempPayment
	}
	if m.Subscription != nil {
		tempSubscription, err := m.Subscription.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Subscription = &tempSubscription
	}
	if posthook, ok := interface{}(m).(ActivityWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Activity the arg will be the target, the caller the one being converted from

// ActivityBeforeToORM called before default ToORM code
type ActivityWithBeforeToORM interface {
	BeforeToORM(context.Context, *ActivityORM) error
}

// ActivityAfterToORM called after default ToORM code
type ActivityWithAfterToORM interface {
	AfterToORM(context.Context, *ActivityORM) error
}

// ActivityBeforeToPB called before default ToPB code
type ActivityWithBeforeToPB interface {
	BeforeToPB(context.Context, *Activity) error
}

// ActivityAfterToPB called after default ToPB code
type ActivityWithAfterToPB interface {
	AfterToPB(context.Context, *Activity) error
}

type LicenseKeyORM struct {
	ActiveUsageId string
	CreatedAt     *time.Time
	Duration      int32
	EffectiveFrom *time.Time
	Id            int64  `gorm:"primaryKey"`
	Key           string `gorm:"unique"`
	Revoked       bool
	SandboxMode   bool
	UpdatedAt     *time.Time
	User          *UserORM `gorm:"foreignKey:UserId;references:Id"`
	UserId        int64
	Uses          int64
}

// TableName overrides the default tablename generated by GORM
func (LicenseKeyORM) TableName() string {
	return "license_keys"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *LicenseKey) ToORM(ctx context.Context) (LicenseKeyORM, error) {
	to := LicenseKeyORM{}
	var err error
	if prehook, ok := interface{}(m).(LicenseKeyWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	if m.EffectiveFrom != nil {
		t := m.EffectiveFrom.AsTime()
		to.EffectiveFrom = &t
	}
	to.Key = m.Key
	to.Revoked = m.Revoked
	to.Duration = int32(m.Duration)
	to.ActiveUsageId = m.ActiveUsageId
	to.Uses = m.Uses
	to.SandboxMode = m.SandboxMode
	if m.User != nil {
		tempUser, err := m.User.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.User = &tempUser
	}
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(LicenseKeyWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *LicenseKeyORM) ToPB(ctx context.Context) (LicenseKey, error) {
	to := LicenseKey{}
	var err error
	if prehook, ok := interface{}(m).(LicenseKeyWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	if m.EffectiveFrom != nil {
		to.EffectiveFrom = timestamppb.New(*m.EffectiveFrom)
	}
	to.Key = m.Key
	to.Revoked = m.Revoked
	to.Duration = LicenseKey_Duration(m.Duration)
	to.ActiveUsageId = m.ActiveUsageId
	to.Uses = m.Uses
	to.SandboxMode = m.SandboxMode
	if m.User != nil {
		tempUser, err := m.User.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.User = &tempUser
	}
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(LicenseKeyWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type LicenseKey the arg will be the target, the caller the one being converted from

// LicenseKeyBeforeToORM called before default ToORM code
type LicenseKeyWithBeforeToORM interface {
	BeforeToORM(context.Context, *LicenseKeyORM) error
}

// LicenseKeyAfterToORM called after default ToORM code
type LicenseKeyWithAfterToORM interface {
	AfterToORM(context.Context, *LicenseKeyORM) error
}

// LicenseKeyBeforeToPB called before default ToPB code
type LicenseKeyWithBeforeToPB interface {
	BeforeToPB(context.Context, *LicenseKey) error
}

// LicenseKeyAfterToPB called after default ToPB code
type LicenseKeyWithAfterToPB interface {
	AfterToPB(context.Context, *LicenseKey) error
}

type PaymentORM struct {
	AmountInCents   int64
	BillingEmail    string
	BillingName     string
	CreatedAt       *time.Time
	Currency        string
	Id              int64 `gorm:"primaryKey"`
	IsRenewal       bool
	LicenseDuration int32
	LicenseKey      *LicenseKeyORM `gorm:"foreignKey:LicenseKeyId;references:Id"`
	LicenseKeyId    *int64
	Provider        int32
	ReferenceId     string `gorm:"unique"`
	SandboxMode     bool
	Subscription    *SubscriptionORM `gorm:"foreignKey:SubscriptionId;references:Id"`
	SubscriptionId  *int64
	UpdatedAt       *time.Time
	User            *UserORM `gorm:"foreignKey:UserId;references:Id"`
	UserId          int64
}

// TableName overrides the default tablename generated by GORM
func (PaymentORM) TableName() string {
	return "payments"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Payment) ToORM(ctx context.Context) (PaymentORM, error) {
	to := PaymentORM{}
	var err error
	if prehook, ok := interface{}(m).(PaymentWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.Provider = int32(m.Provider)
	to.ReferenceId = m.ReferenceId
	to.AmountInCents = m.AmountInCents
	to.Currency = m.Currency
	to.LicenseDuration = int32(m.LicenseDuration)
	to.IsRenewal = m.IsRenewal
	to.SandboxMode = m.SandboxMode
	to.BillingEmail = m.BillingEmail
	to.BillingName = m.BillingName
	if m.User != nil {
		tempUser, err := m.User.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.User = &tempUser
	}
	to.UserId = m.UserId
	if m.LicenseKey != nil {
		tempLicenseKey, err := m.LicenseKey.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.LicenseKey = &tempLicenseKey
	}
	if m.Subscription != nil {
		tempSubscription, err := m.Subscription.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.Subscription = &tempSubscription
	}
	if posthook, ok := interface{}(m).(PaymentWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *PaymentORM) ToPB(ctx context.Context) (Payment, error) {
	to := Payment{}
	var err error
	if prehook, ok := interface{}(m).(PaymentWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.Provider = Payment_Provider(m.Provider)
	to.ReferenceId = m.ReferenceId
	to.AmountInCents = m.AmountInCents
	to.Currency = m.Currency
	to.LicenseDuration = LicenseKey_Duration(m.LicenseDuration)
	to.IsRenewal = m.IsRenewal
	to.SandboxMode = m.SandboxMode
	to.BillingEmail = m.BillingEmail
	to.BillingName = m.BillingName
	if m.User != nil {
		tempUser, err := m.User.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.User = &tempUser
	}
	to.UserId = m.UserId
	if m.LicenseKey != nil {
		tempLicenseKey, err := m.LicenseKey.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.LicenseKey = &tempLicenseKey
	}
	if m.Subscription != nil {
		tempSubscription, err := m.Subscription.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.Subscription = &tempSubscription
	}
	if posthook, ok := interface{}(m).(PaymentWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Payment the arg will be the target, the caller the one being converted from

// PaymentBeforeToORM called before default ToORM code
type PaymentWithBeforeToORM interface {
	BeforeToORM(context.Context, *PaymentORM) error
}

// PaymentAfterToORM called after default ToORM code
type PaymentWithAfterToORM interface {
	AfterToORM(context.Context, *PaymentORM) error
}

// PaymentBeforeToPB called before default ToPB code
type PaymentWithBeforeToPB interface {
	BeforeToPB(context.Context, *Payment) error
}

// PaymentAfterToPB called after default ToPB code
type PaymentWithAfterToPB interface {
	AfterToPB(context.Context, *Payment) error
}

type SubscriptionORM struct {
	CreatedAt            *time.Time
	CurrentPeriodStart   *time.Time
	Duration             int32
	Id                   int64          `gorm:"primaryKey"`
	LicenseKey           *LicenseKeyORM `gorm:"foreignKey:LicenseKeyId;references:Id"`
	LicenseKeyId         int64
	SandboxMode          bool
	Status               int32
	StripeCustomerId     string
	StripeSubscriptionId string `gorm:"unique"`
	UpdatedAt            *time.Time
	User                 *UserORM `gorm:"foreignKey:UserId;references:Id"`
	UserId               int64
}

// TableName overrides the default tablename generated by GORM
func (SubscriptionORM) TableName() string {
	return "subscriptions"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *Subscription) ToORM(ctx context.Context) (SubscriptionORM, error) {
	to := SubscriptionORM{}
	var err error
	if prehook, ok := interface{}(m).(SubscriptionWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.StripeSubscriptionId = m.StripeSubscriptionId
	to.StripeCustomerId = m.StripeCustomerId
	to.Status = int32(m.Status)
	to.Duration = int32(m.Duration)
	if m.CurrentPeriodStart != nil {
		t := m.CurrentPeriodStart.AsTime()
		to.CurrentPeriodStart = &t
	}
	to.SandboxMode = m.SandboxMode
	if m.User != nil {
		tempUser, err := m.User.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.User = &tempUser
	}
	to.UserId = m.UserId
	if m.LicenseKey != nil {
		tempLicenseKey, err := m.LicenseKey.ToORM(ctx)
		if err != nil {
			return to, err
		}
		to.LicenseKey = &tempLicenseKey
	}
	to.LicenseKeyId = m.LicenseKeyId
	if posthook, ok := interface{}(m).(SubscriptionWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *SubscriptionORM) ToPB(ctx context.Context) (Subscription, error) {
	to := Subscription{}
	var err error
	if prehook, ok := interface{}(m).(SubscriptionWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.StripeSubscriptionId = m.StripeSubscriptionId
	to.StripeCustomerId = m.StripeCustomerId
	to.Status = Subscription_Status(m.Status)
	to.Duration = LicenseKey_Duration(m.Duration)
	if m.CurrentPeriodStart != nil {
		to.CurrentPeriodStart = timestamppb.New(*m.CurrentPeriodStart)
	}
	to.SandboxMode = m.SandboxMode
	if m.User != nil {
		tempUser, err := m.User.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.User = &tempUser
	}
	to.UserId = m.UserId
	if m.LicenseKey != nil {
		tempLicenseKey, err := m.LicenseKey.ToPB(ctx)
		if err != nil {
			return to, err
		}
		to.LicenseKey = &tempLicenseKey
	}
	to.LicenseKeyId = m.LicenseKeyId
	if posthook, ok := interface{}(m).(SubscriptionWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type Subscription the arg will be the target, the caller the one being converted from

// SubscriptionBeforeToORM called before default ToORM code
type SubscriptionWithBeforeToORM interface {
	BeforeToORM(context.Context, *SubscriptionORM) error
}

// SubscriptionAfterToORM called after default ToORM code
type SubscriptionWithAfterToORM interface {
	AfterToORM(context.Context, *SubscriptionORM) error
}

// SubscriptionBeforeToPB called before default ToPB code
type SubscriptionWithBeforeToPB interface {
	BeforeToPB(context.Context, *Subscription) error
}

// SubscriptionAfterToPB called after default ToPB code
type SubscriptionWithAfterToPB interface {
	AfterToPB(context.Context, *Subscription) error
}

type UserORM struct {
	CreatedAt   *time.Time
	DiscourseId int64 `gorm:"uniqueIndex:idx_discourse_id"`
	Email       string
	Id          int64 `gorm:"primaryKey"`
	UpdatedAt   *time.Time
	Username    string
}

// TableName overrides the default tablename generated by GORM
func (UserORM) TableName() string {
	return "users"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *User) ToORM(ctx context.Context) (UserORM, error) {
	to := UserORM{}
	var err error
	if prehook, ok := interface{}(m).(UserWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		t := m.CreatedAt.AsTime()
		to.CreatedAt = &t
	}
	if m.UpdatedAt != nil {
		t := m.UpdatedAt.AsTime()
		to.UpdatedAt = &t
	}
	to.DiscourseId = m.DiscourseId
	to.Email = m.Email
	to.Username = m.Username
	if posthook, ok := interface{}(m).(UserWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *UserORM) ToPB(ctx context.Context) (User, error) {
	to := User{}
	var err error
	if prehook, ok := interface{}(m).(UserWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.Id = m.Id
	if m.CreatedAt != nil {
		to.CreatedAt = timestamppb.New(*m.CreatedAt)
	}
	if m.UpdatedAt != nil {
		to.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}
	to.DiscourseId = m.DiscourseId
	to.Email = m.Email
	to.Username = m.Username
	if posthook, ok := interface{}(m).(UserWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type User the arg will be the target, the caller the one being converted from

// UserBeforeToORM called before default ToORM code
type UserWithBeforeToORM interface {
	BeforeToORM(context.Context, *UserORM) error
}

// UserAfterToORM called after default ToORM code
type UserWithAfterToORM interface {
	AfterToORM(context.Context, *UserORM) error
}

// UserBeforeToPB called before default ToPB code
type UserWithBeforeToPB interface {
	BeforeToPB(context.Context, *User) error
}

// UserAfterToPB called after default ToPB code
type UserWithAfterToPB interface {
	AfterToPB(context.Context, *User) error
}

// DefaultCreateActivity executes a basic gorm create call
func DefaultCreateActivity(ctx context.Context, in *Activity, db *gorm.DB) (*Activity, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ActivityORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ActivityORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type ActivityORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ActivityORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadActivity(ctx context.Context, in *Activity, db *gorm.DB) (*Activity, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ActivityORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ActivityORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := ActivityORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(ActivityORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type ActivityORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ActivityORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ActivityORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteActivity(ctx context.Context, in *Activity, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(ActivityORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&ActivityORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(ActivityORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type ActivityORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ActivityORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteActivitySet(ctx context.Context, in []*Activity, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&ActivityORM{})).(ActivityORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&ActivityORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&ActivityORM{})).(ActivityORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type ActivityORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Activity, *gorm.DB) (*gorm.DB, error)
}
type ActivityORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Activity, *gorm.DB) error
}

// DefaultStrictUpdateActivity clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateActivity(ctx context.Context, in *Activity, db *gorm.DB) (*Activity, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateActivity")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &ActivityORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(ActivityORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ActivityORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ActivityORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type ActivityORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ActivityORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ActivityORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchActivity executes a basic gorm update call with patch behavior
func DefaultPatchActivity(ctx context.Context, in *Activity, updateMask *field_mask.FieldMask, db *gorm.DB) (*Activity, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Activity
	var err error
	if hook, ok := interface{}(&pbObj).(ActivityWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadActivity(ctx, &Activity{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(ActivityWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskActivity(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(ActivityWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateActivity(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(ActivityWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type ActivityWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Activity, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ActivityWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Activity, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ActivityWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Activity, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type ActivityWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Activity, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetActivity executes a bulk gorm update call with patch behavior
func DefaultPatchSetActivity(ctx context.Context, objects []*Activity, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Activity, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Activity, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchActivity(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskActivity patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskActivity(ctx context.Context, patchee *Activity, patcher *Activity, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Activity, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedUser bool
	var updatedLicenseKey bool
	var updatedPayment bool
	var updatedSubscription bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Kind" {
			patchee.Kind = patcher.Kind
			continue
		}
		if !updatedUser && strings.HasPrefix(f, prefix+"User.") {
			updatedUser = true
			if patcher.User == nil {
				patchee.User = nil
				continue
			}
			if patchee.User == nil {
				patchee.User = &User{}
			}
			if o, err := DefaultApplyFieldMaskUser(ctx, patchee.User, patcher.User, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"User.", db); err != nil {
				return nil, err
			} else {
				patchee.User = o
			}
			continue
		}
		if f == prefix+"User" {
			updatedUser = true
			patchee.User = patcher.User
			continue
		}
		if !updatedLicenseKey && strings.HasPrefix(f, prefix+"LicenseKey.") {
			updatedLicenseKey = true
			if patcher.LicenseKey == nil {
				patchee.LicenseKey = nil
				continue
			}
			if patchee.LicenseKey == nil {
				patchee.LicenseKey = &LicenseKey{}
			}
			if o, err := DefaultApplyFieldMaskLicenseKey(ctx, patchee.LicenseKey, patcher.LicenseKey, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"LicenseKey.", db); err != nil {
				return nil, err
			} else {
				patchee.LicenseKey = o
			}
			continue
		}
		if f == prefix+"LicenseKey" {
			updatedLicenseKey = true
			patchee.LicenseKey = patcher.LicenseKey
			continue
		}
		if !updatedPayment && strings.HasPrefix(f, prefix+"Payment.") {
			updatedPayment = true
			if patcher.Payment == nil {
				patchee.Payment = nil
				continue
			}
			if patchee.Payment == nil {
				patchee.Payment = &Payment{}
			}
			if o, err := DefaultApplyFieldMaskPayment(ctx, patchee.Payment, patcher.Payment, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Payment.", db); err != nil {
				return nil, err
			} else {
				patchee.Payment = o
			}
			continue
		}
		if f == prefix+"Payment" {
			updatedPayment = true
			patchee.Payment = patcher.Payment
			continue
		}
		if !updatedSubscription && strings.HasPrefix(f, prefix+"Subscription.") {
			updatedSubscription = true
			if patcher.Subscription == nil {
				patchee.Subscription = nil
				continue
			}
			if patchee.Subscription == nil {
				patchee.Subscription = &Subscription{}
			}
			if o, err := DefaultApplyFieldMaskSubscription(ctx, patchee.Subscription, patcher.Subscription, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Subscription.", db); err != nil {
				return nil, err
			} else {
				patchee.Subscription = o
			}
			continue
		}
		if f == prefix+"Subscription" {
			updatedSubscription = true
			patchee.Subscription = patcher.Subscription
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListActivity executes a gorm list call
func DefaultListActivity(ctx context.Context, db *gorm.DB) ([]*Activity, error) {
	in := Activity{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ActivityORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(ActivityORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []ActivityORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(ActivityORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Activity{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type ActivityORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ActivityORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type ActivityORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]ActivityORM) error
}

// DefaultCreateLicenseKey executes a basic gorm create call
func DefaultCreateLicenseKey(ctx context.Context, in *LicenseKey, db *gorm.DB) (*LicenseKey, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LicenseKeyORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LicenseKeyORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type LicenseKeyORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LicenseKeyORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadLicenseKey(ctx context.Context, in *LicenseKey, db *gorm.DB) (*LicenseKey, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LicenseKeyORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(LicenseKeyORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := LicenseKeyORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(LicenseKeyORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type LicenseKeyORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LicenseKeyORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LicenseKeyORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteLicenseKey(ctx context.Context, in *LicenseKey, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(LicenseKeyORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&LicenseKeyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(LicenseKeyORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type LicenseKeyORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LicenseKeyORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteLicenseKeySet(ctx context.Context, in []*LicenseKey, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&LicenseKeyORM{})).(LicenseKeyORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&LicenseKeyORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&LicenseKeyORM{})).(LicenseKeyORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type LicenseKeyORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*LicenseKey, *gorm.DB) (*gorm.DB, error)
}
type LicenseKeyORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*LicenseKey, *gorm.DB) error
}

// DefaultStrictUpdateLicenseKey clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateLicenseKey(ctx context.Context, in *LicenseKey, db *gorm.DB) (*LicenseKey, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateLicenseKey")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &LicenseKeyORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(LicenseKeyORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(LicenseKeyORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LicenseKeyORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type LicenseKeyORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LicenseKeyORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LicenseKeyORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchLicenseKey executes a basic gorm update call with patch behavior
func DefaultPatchLicenseKey(ctx context.Context, in *LicenseKey, updateMask *field_mask.FieldMask, db *gorm.DB) (*LicenseKey, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj LicenseKey
	var err error
	if hook, ok := interface{}(&pbObj).(LicenseKeyWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadLicenseKey(ctx, &LicenseKey{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(LicenseKeyWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskLicenseKey(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(LicenseKeyWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateLicenseKey(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(LicenseKeyWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type LicenseKeyWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *LicenseKey, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LicenseKeyWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *LicenseKey, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LicenseKeyWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *LicenseKey, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type LicenseKeyWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *LicenseKey, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetLicenseKey executes a bulk gorm update call with patch behavior
func DefaultPatchSetLicenseKey(ctx context.Context, objects []*LicenseKey, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*LicenseKey, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*LicenseKey, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchLicenseKey(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskLicenseKey patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskLicenseKey(ctx context.Context, patchee *LicenseKey, patcher *LicenseKey, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*LicenseKey, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedEffectiveFrom bool
	var updatedUser bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if !updatedEffectiveFrom && strings.HasPrefix(f, prefix+"EffectiveFrom.") {
			if patcher.EffectiveFrom == nil {
				patchee.EffectiveFrom = nil
				continue
			}
			if patchee.EffectiveFrom == nil {
				patchee.EffectiveFrom = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"EffectiveFrom."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.EffectiveFrom, patchee.EffectiveFrom, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"EffectiveFrom" {
			updatedEffectiveFrom = true
			patchee.EffectiveFrom = patcher.EffectiveFrom
			continue
		}
		if f == prefix+"Key" {
			patchee.Key = patcher.Key
			continue
		}
		if f == prefix+"Revoked" {
			patchee.Revoked = patcher.Revoked
			continue
		}
		if f == prefix+"Duration" {
			patchee.Duration = patcher.Duration
			continue
		}
		if f == prefix+"ActiveUsageId" {
			patchee.ActiveUsageId = patcher.ActiveUsageId
			continue
		}
		if f == prefix+"Uses" {
			patchee.Uses = patcher.Uses
			continue
		}
		if f == prefix+"SandboxMode" {
			patchee.SandboxMode = patcher.SandboxMode
			continue
		}
		if !updatedUser && strings.HasPrefix(f, prefix+"User.") {
			updatedUser = true
			if patcher.User == nil {
				patchee.User = nil
				continue
			}
			if patchee.User == nil {
				patchee.User = &User{}
			}
			if o, err := DefaultApplyFieldMaskUser(ctx, patchee.User, patcher.User, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"User.", db); err != nil {
				return nil, err
			} else {
				patchee.User = o
			}
			continue
		}
		if f == prefix+"User" {
			updatedUser = true
			patchee.User = patcher.User
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListLicenseKey executes a gorm list call
func DefaultListLicenseKey(ctx context.Context, db *gorm.DB) ([]*LicenseKey, error) {
	in := LicenseKey{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LicenseKeyORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(LicenseKeyORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []LicenseKeyORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(LicenseKeyORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*LicenseKey{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type LicenseKeyORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LicenseKeyORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type LicenseKeyORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]LicenseKeyORM) error
}

// DefaultCreatePayment executes a basic gorm create call
func DefaultCreatePayment(ctx context.Context, in *Payment, db *gorm.DB) (*Payment, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type PaymentORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadPayment(ctx context.Context, in *Payment, db *gorm.DB) (*Payment, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := PaymentORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(PaymentORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type PaymentORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeletePayment(ctx context.Context, in *Payment, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&PaymentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type PaymentORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeletePaymentSet(ctx context.Context, in []*Payment, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&PaymentORM{})).(PaymentORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&PaymentORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&PaymentORM{})).(PaymentORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type PaymentORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Payment, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Payment, *gorm.DB) error
}

// DefaultStrictUpdatePayment clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdatePayment(ctx context.Context, in *Payment, db *gorm.DB) (*Payment, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdatePayment")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &PaymentORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type PaymentORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchPayment executes a basic gorm update call with patch behavior
func DefaultPatchPayment(ctx context.Context, in *Payment, updateMask *field_mask.FieldMask, db *gorm.DB) (*Payment, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Payment
	var err error
	if hook, ok := interface{}(&pbObj).(PaymentWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadPayment(ctx, &Payment{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(PaymentWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskPayment(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(PaymentWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdatePayment(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(PaymentWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type PaymentWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Payment, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PaymentWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Payment, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PaymentWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Payment, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type PaymentWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Payment, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetPayment executes a bulk gorm update call with patch behavior
func DefaultPatchSetPayment(ctx context.Context, objects []*Payment, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Payment, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Payment, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchPayment(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskPayment patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskPayment(ctx context.Context, patchee *Payment, patcher *Payment, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Payment, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedUser bool
	var updatedLicenseKey bool
	var updatedSubscription bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"Provider" {
			patchee.Provider = patcher.Provider
			continue
		}
		if f == prefix+"ReferenceId" {
			patchee.ReferenceId = patcher.ReferenceId
			continue
		}
		if f == prefix+"AmountInCents" {
			patchee.AmountInCents = patcher.AmountInCents
			continue
		}
		if f == prefix+"Currency" {
			patchee.Currency = patcher.Currency
			continue
		}
		if f == prefix+"LicenseDuration" {
			patchee.LicenseDuration = patcher.LicenseDuration
			continue
		}
		if f == prefix+"IsRenewal" {
			patchee.IsRenewal = patcher.IsRenewal
			continue
		}
		if f == prefix+"SandboxMode" {
			patchee.SandboxMode = patcher.SandboxMode
			continue
		}
		if f == prefix+"BillingEmail" {
			patchee.BillingEmail = patcher.BillingEmail
			continue
		}
		if f == prefix+"BillingName" {
			patchee.BillingName = patcher.BillingName
			continue
		}
		if !updatedUser && strings.HasPrefix(f, prefix+"User.") {
			updatedUser = true
			if patcher.User == nil {
				patchee.User = nil
				continue
			}
			if patchee.User == nil {
				patchee.User = &User{}
			}
			if o, err := DefaultApplyFieldMaskUser(ctx, patchee.User, patcher.User, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"User.", db); err != nil {
				return nil, err
			} else {
				patchee.User = o
			}
			continue
		}
		if f == prefix+"User" {
			updatedUser = true
			patchee.User = patcher.User
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if !updatedLicenseKey && strings.HasPrefix(f, prefix+"LicenseKey.") {
			updatedLicenseKey = true
			if patcher.LicenseKey == nil {
				patchee.LicenseKey = nil
				continue
			}
			if patchee.LicenseKey == nil {
				patchee.LicenseKey = &LicenseKey{}
			}
			if o, err := DefaultApplyFieldMaskLicenseKey(ctx, patchee.LicenseKey, patcher.LicenseKey, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"LicenseKey.", db); err != nil {
				return nil, err
			} else {
				patchee.LicenseKey = o
			}
			continue
		}
		if f == prefix+"LicenseKey" {
			updatedLicenseKey = true
			patchee.LicenseKey = patcher.LicenseKey
			continue
		}
		if !updatedSubscription && strings.HasPrefix(f, prefix+"Subscription.") {
			updatedSubscription = true
			if patcher.Subscription == nil {
				patchee.Subscription = nil
				continue
			}
			if patchee.Subscription == nil {
				patchee.Subscription = &Subscription{}
			}
			if o, err := DefaultApplyFieldMaskSubscription(ctx, patchee.Subscription, patcher.Subscription, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"Subscription.", db); err != nil {
				return nil, err
			} else {
				patchee.Subscription = o
			}
			continue
		}
		if f == prefix+"Subscription" {
			updatedSubscription = true
			patchee.Subscription = patcher.Subscription
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListPayment executes a gorm list call
func DefaultListPayment(ctx context.Context, db *gorm.DB) ([]*Payment, error) {
	in := Payment{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []PaymentORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(PaymentORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Payment{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type PaymentORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type PaymentORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]PaymentORM) error
}

// DefaultCreateSubscription executes a basic gorm create call
func DefaultCreateSubscription(ctx context.Context, in *Subscription, db *gorm.DB) (*Subscription, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type SubscriptionORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SubscriptionORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadSubscription(ctx context.Context, in *Subscription, db *gorm.DB) (*Subscription, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := SubscriptionORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(SubscriptionORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type SubscriptionORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SubscriptionORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SubscriptionORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteSubscription(ctx context.Context, in *Subscription, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&SubscriptionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type SubscriptionORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SubscriptionORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteSubscriptionSet(ctx context.Context, in []*Subscription, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&SubscriptionORM{})).(SubscriptionORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&SubscriptionORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&SubscriptionORM{})).(SubscriptionORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type SubscriptionORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*Subscription, *gorm.DB) (*gorm.DB, error)
}
type SubscriptionORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*Subscription, *gorm.DB) error
}

// DefaultStrictUpdateSubscription clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateSubscription(ctx context.Context, in *Subscription, db *gorm.DB) (*Subscription, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateSubscription")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &SubscriptionORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(SubscriptionORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type SubscriptionORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SubscriptionORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SubscriptionORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchSubscription executes a basic gorm update call with patch behavior
func DefaultPatchSubscription(ctx context.Context, in *Subscription, updateMask *field_mask.FieldMask, db *gorm.DB) (*Subscription, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj Subscription
	var err error
	if hook, ok := interface{}(&pbObj).(SubscriptionWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadSubscription(ctx, &Subscription{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(SubscriptionWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskSubscription(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(SubscriptionWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateSubscription(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(SubscriptionWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type SubscriptionWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *Subscription, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SubscriptionWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *Subscription, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SubscriptionWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *Subscription, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type SubscriptionWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *Subscription, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetSubscription executes a bulk gorm update call with patch behavior
func DefaultPatchSetSubscription(ctx context.Context, objects []*Subscription, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*Subscription, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*Subscription, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchSubscription(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskSubscription patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskSubscription(ctx context.Context, patchee *Subscription, patcher *Subscription, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*Subscription, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	var updatedCurrentPeriodStart bool
	var updatedUser bool
	var updatedLicenseKey bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"StripeSubscriptionId" {
			patchee.StripeSubscriptionId = patcher.StripeSubscriptionId
			continue
		}
		if f == prefix+"StripeCustomerId" {
			patchee.StripeCustomerId = patcher.StripeCustomerId
			continue
		}
		if f == prefix+"Status" {
			patchee.Status = patcher.Status
			continue
		}
		if f == prefix+"Duration" {
			patchee.Duration = patcher.Duration
			continue
		}
		if !updatedCurrentPeriodStart && strings.HasPrefix(f, prefix+"CurrentPeriodStart.") {
			if patcher.CurrentPeriodStart == nil {
				patchee.CurrentPeriodStart = nil
				continue
			}
			if patchee.CurrentPeriodStart == nil {
				patchee.CurrentPeriodStart = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CurrentPeriodStart."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CurrentPeriodStart, patchee.CurrentPeriodStart, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CurrentPeriodStart" {
			updatedCurrentPeriodStart = true
			patchee.CurrentPeriodStart = patcher.CurrentPeriodStart
			continue
		}
		if f == prefix+"SandboxMode" {
			patchee.SandboxMode = patcher.SandboxMode
			continue
		}
		if !updatedUser && strings.HasPrefix(f, prefix+"User.") {
			updatedUser = true
			if patcher.User == nil {
				patchee.User = nil
				continue
			}
			if patchee.User == nil {
				patchee.User = &User{}
			}
			if o, err := DefaultApplyFieldMaskUser(ctx, patchee.User, patcher.User, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"User.", db); err != nil {
				return nil, err
			} else {
				patchee.User = o
			}
			continue
		}
		if f == prefix+"User" {
			updatedUser = true
			patchee.User = patcher.User
			continue
		}
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
		if !updatedLicenseKey && strings.HasPrefix(f, prefix+"LicenseKey.") {
			updatedLicenseKey = true
			if patcher.LicenseKey == nil {
				patchee.LicenseKey = nil
				continue
			}
			if patchee.LicenseKey == nil {
				patchee.LicenseKey = &LicenseKey{}
			}
			if o, err := DefaultApplyFieldMaskLicenseKey(ctx, patchee.LicenseKey, patcher.LicenseKey, &field_mask.FieldMask{Paths: updateMask.Paths[i:]}, prefix+"LicenseKey.", db); err != nil {
				return nil, err
			} else {
				patchee.LicenseKey = o
			}
			continue
		}
		if f == prefix+"LicenseKey" {
			updatedLicenseKey = true
			patchee.LicenseKey = patcher.LicenseKey
			continue
		}
		if f == prefix+"LicenseKeyId" {
			patchee.LicenseKeyId = patcher.LicenseKeyId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListSubscription executes a gorm list call
func DefaultListSubscription(ctx context.Context, db *gorm.DB) ([]*Subscription, error) {
	in := Subscription{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []SubscriptionORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SubscriptionORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*Subscription{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type SubscriptionORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SubscriptionORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SubscriptionORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]SubscriptionORM) error
}

// DefaultCreateUser executes a basic gorm create call
func DefaultCreateUser(ctx context.Context, in *User, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type UserORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

func DefaultReadUser(ctx context.Context, in *User, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if ormObj.Id == 0 {
		return nil, errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeReadApplyQuery); ok {
		if db, err = hook.BeforeReadApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeReadFind); ok {
		if db, err = hook.BeforeReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	ormResponse := UserORM{}
	if err = db.Where(&ormObj).First(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormResponse).(UserORMWithAfterReadFind); ok {
		if err = hook.AfterReadFind(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormResponse.ToPB(ctx)
	return &pbResponse, err
}

type UserORMWithBeforeReadApplyQuery interface {
	BeforeReadApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithBeforeReadFind interface {
	BeforeReadFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterReadFind interface {
	AfterReadFind(context.Context, *gorm.DB) error
}

func DefaultDeleteUser(ctx context.Context, in *User, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return err
	}
	if ormObj.Id == 0 {
		return errors.EmptyIdError
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeDelete_); ok {
		if db, err = hook.BeforeDelete_(ctx, db); err != nil {
			return err
		}
	}
	err = db.Where(&ormObj).Delete(&UserORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterDelete_); ok {
		err = hook.AfterDelete_(ctx, db)
	}
	return err
}

type UserORMWithBeforeDelete_ interface {
	BeforeDelete_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterDelete_ interface {
	AfterDelete_(context.Context, *gorm.DB) error
}

func DefaultDeleteUserSet(ctx context.Context, in []*User, db *gorm.DB) error {
	if in == nil {
		return errors.NilArgumentError
	}
	var err error
	keys := []int64{}
	for _, obj := range in {
		ormObj, err := obj.ToORM(ctx)
		if err != nil {
			return err
		}
		if ormObj.Id == 0 {
			return errors.EmptyIdError
		}
		keys = append(keys, ormObj.Id)
	}
	if hook, ok := (interface{}(&UserORM{})).(UserORMWithBeforeDeleteSet); ok {
		if db, err = hook.BeforeDeleteSet(ctx, in, db); err != nil {
			return err
		}
	}
	err = db.Where("id in (?)", keys).Delete(&UserORM{}).Error
	if err != nil {
		return err
	}
	if hook, ok := (interface{}(&UserORM{})).(UserORMWithAfterDeleteSet); ok {
		err = hook.AfterDeleteSet(ctx, in, db)
	}
	return err
}

type UserORMWithBeforeDeleteSet interface {
	BeforeDeleteSet(context.Context, []*User, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterDeleteSet interface {
	AfterDeleteSet(context.Context, []*User, *gorm.DB) error
}

// DefaultStrictUpdateUser clears / replaces / appends first level 1:many children and then executes a gorm update call
func DefaultStrictUpdateUser(ctx context.Context, in *User, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, fmt.Errorf("Nil argument to DefaultStrictUpdateUser")
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	lockedRow := &UserORM{}
	db.Model(&ormObj).Set("gorm:query_option", "FOR UPDATE").Where("id=?", ormObj.Id).First(lockedRow)
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeStrictUpdateCleanup); ok {
		if db, err = hook.BeforeStrictUpdateCleanup(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeStrictUpdateSave); ok {
		if db, err = hook.BeforeStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Omit().Save(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterStrictUpdateSave); ok {
		if err = hook.AfterStrictUpdateSave(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	if err != nil {
		return nil, err
	}
	return &pbResponse, err
}

type UserORMWithBeforeStrictUpdateCleanup interface {
	BeforeStrictUpdateCleanup(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithBeforeStrictUpdateSave interface {
	BeforeStrictUpdateSave(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterStrictUpdateSave interface {
	AfterStrictUpdateSave(context.Context, *gorm.DB) error
}

// DefaultPatchUser executes a basic gorm update call with patch behavior
func DefaultPatchUser(ctx context.Context, in *User, updateMask *field_mask.FieldMask, db *gorm.DB) (*User, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	var pbObj User
	var err error
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchRead); ok {
		if db, err = hook.BeforePatchRead(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbReadRes, err := DefaultReadUser(ctx, &User{Id: in.GetId()}, db)
	if err != nil {
		return nil, err
	}
	pbObj = *pbReadRes
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchApplyFieldMask); ok {
		if db, err = hook.BeforePatchApplyFieldMask(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	if _, err := DefaultApplyFieldMaskUser(ctx, &pbObj, in, updateMask, "", db); err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&pbObj).(UserWithBeforePatchSave); ok {
		if db, err = hook.BeforePatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := DefaultStrictUpdateUser(ctx, &pbObj, db)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(pbResponse).(UserWithAfterPatchSave); ok {
		if err = hook.AfterPatchSave(ctx, in, updateMask, db); err != nil {
			return nil, err
		}
	}
	return pbResponse, nil
}

type UserWithBeforePatchRead interface {
	BeforePatchRead(context.Context, *User, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWithBeforePatchApplyFieldMask interface {
	BeforePatchApplyFieldMask(context.Context, *User, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWithBeforePatchSave interface {
	BeforePatchSave(context.Context, *User, *field_mask.FieldMask, *gorm.DB) (*gorm.DB, error)
}
type UserWithAfterPatchSave interface {
	AfterPatchSave(context.Context, *User, *field_mask.FieldMask, *gorm.DB) error
}

// DefaultPatchSetUser executes a bulk gorm update call with patch behavior
func DefaultPatchSetUser(ctx context.Context, objects []*User, updateMasks []*field_mask.FieldMask, db *gorm.DB) ([]*User, error) {
	if len(objects) != len(updateMasks) {
		return nil, fmt.Errorf(errors.BadRepeatedFieldMaskTpl, len(updateMasks), len(objects))
	}

	results := make([]*User, 0, len(objects))
	for i, patcher := range objects {
		pbResponse, err := DefaultPatchUser(ctx, patcher, updateMasks[i], db)
		if err != nil {
			return nil, err
		}

		results = append(results, pbResponse)
	}

	return results, nil
}

// DefaultApplyFieldMaskUser patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskUser(ctx context.Context, patchee *User, patcher *User, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*User, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	var updatedCreatedAt bool
	var updatedUpdatedAt bool
	for i, f := range updateMask.Paths {
		if f == prefix+"Id" {
			patchee.Id = patcher.Id
			continue
		}
		if !updatedCreatedAt && strings.HasPrefix(f, prefix+"CreatedAt.") {
			if patcher.CreatedAt == nil {
				patchee.CreatedAt = nil
				continue
			}
			if patchee.CreatedAt == nil {
				patchee.CreatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"CreatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.CreatedAt, patchee.CreatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"CreatedAt" {
			updatedCreatedAt = true
			patchee.CreatedAt = patcher.CreatedAt
			continue
		}
		if !updatedUpdatedAt && strings.HasPrefix(f, prefix+"UpdatedAt.") {
			if patcher.UpdatedAt == nil {
				patchee.UpdatedAt = nil
				continue
			}
			if patchee.UpdatedAt == nil {
				patchee.UpdatedAt = &timestamppb.Timestamp{}
			}
			childMask := &field_mask.FieldMask{}
			for j := i; j < len(updateMask.Paths); j++ {
				if trimPath := strings.TrimPrefix(updateMask.Paths[j], prefix+"UpdatedAt."); trimPath != updateMask.Paths[j] {
					childMask.Paths = append(childMask.Paths, trimPath)
				}
			}
			if err := gorm1.MergeWithMask(patcher.UpdatedAt, patchee.UpdatedAt, childMask); err != nil {
				return nil, nil
			}
		}
		if f == prefix+"UpdatedAt" {
			updatedUpdatedAt = true
			patchee.UpdatedAt = patcher.UpdatedAt
			continue
		}
		if f == prefix+"DiscourseId" {
			patchee.DiscourseId = patcher.DiscourseId
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
		if f == prefix+"Username" {
			patchee.Username = patcher.Username
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListUser executes a gorm list call
func DefaultListUser(ctx context.Context, db *gorm.DB) ([]*User, error) {
	in := User{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	db = db.Order("id")
	ormResponse := []UserORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(UserORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*User{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type UserORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type UserORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]UserORM) error
}
